<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>视频处理学习 - 计算机视觉技术指南</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header>
        <nav class="navbar">
            <div class="logo">
                <h1>VideoLearn</h1>
            </div>
            <ul class="nav-links">
                <li><a href="#basics">基础知识</a></li>
                <li><a href="#codec">编解码</a></li>
                <li><a href="#ai">AI处理</a></li>
                <li><a href="#tools">工具框架</a></li>
                <li><a href="#code">代码示例</a></li>
            </ul>
        </nav>
    </header>

    <section id="basics" class="section">
        <div class="container">
            <h2>基础知识</h2>

            <div class="topic-list">
                <div class="topic-item">
                    <h3>1. 视频的基本概念与表示</h3>
                    <p>视频是连续的图像序列，每张图像称为一帧（Frame）。理解视频的数学表示和物理特性是深入学习视频处理的基础。</p>
                    <ul>
                        <li><strong>帧率（FPS, Frames Per Second）</strong>：每秒显示的帧数，影响视频流畅度和时间分辨率</li>
                        <li><strong>分辨率</strong>：视频的空间分辨率，如720p(1280×720)、1080p(1920×1080)、4K(3840×2160)</li>
                        <li><strong>码率（Bitrate）</strong>：每秒视频数据量，单位bps，影响视频质量</li>
                        <li><strong>长宽比</strong>：视频帧的宽高比，常见16:9、4:3、21:9</li>
                        <li><strong>像素深度</strong>：每个像素的位数，如8-bit、10-bit，影响色彩表现</li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>2. 色彩空间与转换</h3>
                    <p>色彩空间定义了颜色的表示方式。不同应用场景使用不同的色彩空间，理解转换原理对视频处理至关重要。</p>
                    <ul>
                        <li><strong>RGB色彩空间</strong>：加色模型，适合显示设备。R(红)、G(绿)、B(蓝)三个通道混合</li>
                        <li><strong>YUV/YCbCr色彩空间</strong>：亮色分离模型。Y表示亮度，U/V表示色度，常用于视频压缩</li>
                        <li><strong>色彩空间转换</strong>：RGB与YUV的线性转换关系，BT.601、BT.709、BT.2020标准</li>
                        <li><strong>色度采样</strong>：人眼对亮度敏感，可降低色度分辨率。格式包括4:4:4、4:2:2、4:2:0、4:1:1</li>
                        <li><strong>示例转换</strong>：Y = 0.299R + 0.587G + 0.114B (BT.601标准)</li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>3. 视频容器格式与编码格式</h3>
                    <p>容器格式（Container）是封装音频、视频、字幕等流的"盒子"，编码格式（Codec）是压缩编码的具体方法。</p>
                    <ul>
                        <li><strong>容器格式</strong>：MP4(MPEG-4 Part 14)、MKV(Matroska)、WebM、AVI、MOV</li>
                        <li><strong>视频编码</strong>：H.264/AVC、H.265/HEVC、VP9、AV1、MPEG-2、MJPEG</li>
                        <li><strong>音频编码</strong>：AAC、MP3、Opus、FLAC、AC-3</li>
                        <li><strong>容器与编码关系</strong>：同一容器可使用不同编码，如MP4容器可用H.264或H.265编码</li>
                        <li><strong>格式选择原则</strong>：根据兼容性、压缩效率、质量需求选择合适组合</li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>4. 图像处理基础理论</h3>
                    <p>视频本质是图像序列，掌握图像处理的基础理论是视频处理的核心前提。</p>
                    <ul>
                        <li><strong>数字图像表示</strong>：二维函数f(x,y)，(x,y)为空间坐标，f为幅值</li>
                        <li><strong>空域滤波</strong>：直接在图像空间进行滤波操作
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>线性滤波：均值滤波、高斯滤波</li>
                                <li>非线性滤波：中值滤波、双边滤波</li>
                                <li>卷积运算：g(x,y) = f(x,y) * h(x,y)，h为卷积核</li>
                            </ul>
                        </li>
                        <li><strong>频域处理</strong>：通过傅里叶变换在频域分析图像特性
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>DFT(离散傅里叶变换)、FFT(快速傅里叶变换)</li>
                                <li>频域滤波：低通(去噪)、高通(边缘增强)</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>5. 图像变换技术</h3>
                    <p>图像变换将图像从空域转换到变换域，便于压缩、分析和处理。视频压缩的核心技术之一。</p>
                    <ul>
                        <li><strong>DCT(离散余弦变换)</strong>：JPEG、H.264、H.265的核心变换
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>将图像块从空域转换到频域</li>
                                <li>能量集中在低频系数，便于压缩</li>
                                <li>8×8块DCT为视频压缩标准变换</li>
                            </ul>
                        </li>
                        <li><strong>DWT(离散小波变换)</strong>：多分辨率分析
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>JPEG 2000采用的技术</li>
                                <li>时频局部化特性优于DCT</li>
                            </ul>
                        </li>
                        <li><strong>量化</strong>：有损压缩的关键步骤
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>量化系数 = round(变换系数 / 量化步长)</li>
                                <li>量化步长越大，压缩率越高但失真越大</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>6. 边缘检测与特征提取</h3>
                    <p>边缘是图像中重要的特征，边缘检测是计算机视觉的基础操作。</p>
                    <ul>
                        <li><strong>梯度算子</strong>：基于一阶导数的边缘检测
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>Sobel算子：考虑加权，抗噪性强</li>
                                <li>Prewitt算子：简单的梯度算子</li>
                                <li>Roberts算子：交叉梯度算子</li>
                            </ul>
                        </li>
                        <li><strong>二阶导数</strong>：基于拉普拉斯算子
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>Laplacian算子：检测零交叉点</li>
                                <li>LoG算子：高斯-拉普拉斯算子</li>
                            </ul>
                        </li>
                        <li><strong>Canny边缘检测</strong>：多阶段最优边缘检测算法
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>高斯滤波去噪</li>
                                <li>计算梯度幅值和方向</li>
                                <li>非极大值抑制</li>
                                <li>双阈值检测和边缘连接</li>
                            </ul>
                        </li>
                        <li><strong>Harris角点检测</strong>：检测图像中的角点特征</li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>7. 运动估计与运动补偿</h3>
                    <p>运动估计和运动补偿是视频压缩的核心技术，利用视频帧间的时空相关性减少冗余。</p>
                    <ul>
                        <li><strong>运动估计原理</strong>：寻找当前帧与参考帧之间的对应关系
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>帧间相关性：相邻帧内容相似度高</li>
                                <li>运动矢量(MV)：表示块在参考帧中的位移</li>
                            </ul>
                        </li>
                        <li><strong>块匹配算法(BMA)</strong>：最常用的运动估计方法
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>将当前帧划分为宏块（如16×16）</li>
                                <li>在参考帧的搜索窗内寻找最佳匹配块</li>
                                <li>匹配准则：SAD(绝对差和)、SSD(平方差和)</li>
                            </ul>
                        </li>
                        <li><strong>搜索策略</strong>
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>全搜索：最精确但计算量大</li>
                                <li>三步搜索、四步搜索：快速搜索算法</li>
                                <li>钻石搜索、六边形搜索：进一步优化</li>
                            </ul>
                        </li>
                        <li><strong>光流法</strong>：基于像素级的运动估计
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>Lucas-Kanade方法</li>
                                <li>Horn-Schunck方法</li>
                                <li>稠密光流 vs 稀疏光流</li>
                            </ul>
                        </li>
                        <li><strong>运动补偿</strong>：利用运动矢量预测当前帧
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>前向预测（P帧）</li>
                                <li>双向预测（B帧）</li>
                                <li>帧内预测（I帧）</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>8. 视频帧类型与GOP结构</h3>
                    <p>理解视频编码中的帧类型和GOP（图像组）结构对视频压缩和随机访问至关重要。</p>
                    <ul>
                        <li><strong>I帧（Intra Frame）</strong>：帧内编码帧
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>不依赖其他帧，可独立解码</li>
                                <li>作为随机访问点</li>
                                <li>数据量最大，压缩效率最低</li>
                            </ul>
                        </li>
                        <li><strong>P帧（Predicted Frame）</strong>：前向预测帧
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>参考前向I帧或P帧</li>
                                <li>使用运动补偿</li>
                                <li>数据量小于I帧</li>
                            </ul>
                        </li>
                        <li><strong>B帧（Bi-directional Predicted Frame）</strong>：双向预测帧
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>参考前后帧进行预测</li>
                                <li>压缩效率最高，数据量最小</li>
                                <li>增加延迟和复杂度</li>
                            </ul>
                        </li>
                        <li><strong>GOP（Group of Pictures）</strong>：图像组结构
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>定义帧的排列模式，如IBBPBBPBBPI</li>
                                <li>GOP长度影响压缩率和随机访问能力</li>
                                <li>开放GOP vs 闭合GOP</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>9. 视频质量评估指标</h3>
                    <p>视频质量评估是视频处理中重要的评价指标，用于衡量压缩、增强等处理的效果。</p>
                    <ul>
                        <li><strong>主观质量评估</strong>：通过人眼直接评价
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>MOS（平均意见分）</li>
                                <li>DMOS（差分平均意见分）</li>
                                <li>符合ITU-R BT.500标准</li>
                            </ul>
                        </li>
                        <li><strong>客观质量评估 - 全参考</strong>：需要原始视频
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li><strong>PSNR（峰值信噪比）</strong>：最常用的指标
                                    <ul style="margin-left:20px; margin-top:3px;">
                                        <li>PSNR = 10·log₁₀(MAX²/MSE)</li>
                                        <li>值越大质量越好，>30dB为可接受</li>
                                    </ul>
                                </li>
                                <li><strong>SSIM（结构相似性）</strong>：更符合人眼感知
                                    <ul style="margin-left:20px; margin-top:3px;">
                                        <li>考虑亮度、对比度、结构</li>
                                        <li>范围[0,1]，值越大质量越好</li>
                                    </ul>
                                </li>
                                <li><strong>VMAF（视频多方法评估融合）</strong>：Netflix开源
                                    <ul style="margin-left:20px; margin-top:3px;">
                                        <li>融合多个指标，更准确</li>
                                        <li>广泛用于行业评估</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><strong>无参考质量评估（NR-IQA）</strong>：不需要原始视频
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>基于自然场景统计的方法</li>
                                <li>深度学习质量评估模型</li>
                            </ul>
                        </li>
                    </ul>
                </div>

                <div class="topic-item">
                    <h3>10. 视频压缩的基本原理</h3>
                    <p>视频压缩通过去除冗余来实现高效编码，是视频处理的核心技术。</p>
                    <ul>
                        <li><strong>空间冗余</strong>：帧内像素的相关性
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>帧内预测（Intra Prediction）</li>
                                <li>变换编码（DCT）压缩空域冗余</li>
                            </ul>
                        </li>
                        <li><strong>时间冗余</strong>：帧与帧之间的相关性
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>帧间预测（Inter Prediction）</li>
                                <li>运动估计与运动补偿</li>
                            </ul>
                        </li>
                        <li><strong>编码冗余</strong>：编码符号的统计冗余
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>熵编码（Entropy Coding）</li>
                                <li>Huffman编码、算术编码、CABAC</li>
                            </ul>
                        </li>
                        <li><strong>视觉冗余</strong>：人眼对某些信息不敏感
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>量化去除高频细节</li>
                                <li>色度采样</li>
                            </ul>
                        </li>
                        <li><strong>率失真优化（RDO）</strong>：平衡码率和质量
                            <ul style="margin-top:5px; margin-left:20px;">
                                <li>代价函数：J = D + λ·R</li>
                                <li>D：失真，R：码率，λ：拉格朗日乘子</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <section id="codec" class="section alt-bg">
        <div class="container">
            <h2>视频编解码技术</h2>
            <div class="codec-grid">
                <div class="codec-card">
                    <h3>H.264/AVC</h3>
                    <span class="tag">标准</span>
                    <p>广泛应用的视频编码标准，平衡压缩效率与解码复杂度</p>
                    <div class="spec">
                        <span>压缩比: 50:1</span>
                        <span>主流支持</span>
                    </div>
                </div>
                <div class="codec-card featured">
                    <h3>H.265/HEVC</h3>
                    <span class="tag hot">主流</span>
                    <p>比H.264压缩效率提升50%，支持4K/8K视频</p>
                    <div class="spec">
                        <span>压缩比: 100:1</span>
                        <span>广泛应用</span>
                    </div>
                </div>
                <div class="codec-card">
                    <h3>AV1</h3>
                    <span class="tag">开源</span>
                    <p>免版税的新一代编码标准，比H.265更高效</p>
                    <div class="spec">
                        <span>压缩比: 120:1</span>
                        <span>Web首选</span>
                    </div>
                </div>
                <div class="codec-card featured">
                    <h3>H.266/VVC</h3>
                    <span class="tag latest">最新标准</span>
                    <p>最新国际标准，压缩效率比H.265提升50%</p>
                    <div class="spec">
                        <span>压缩比: 150:1</span>
                        <span>8K+支持</span>
                    </div>
                </div>
                <div class="codec-card">
                    <h3>EVC</h3>
                    <span class="tag">专利友好</span>
                    <p>免版税编码标准，适合商业应用</p>
                    <div class="spec">
                        <span>压缩比: 90:1</span>
                        <span>低许可费</span>
                    </div>
                </div>
                <div class="codec-card">
                    <h3>VP9</h3>
                    <span class="tag">Google</span>
                    <p>Google推出的开源编码，YouTube主要格式</p>
                    <div class="spec">
                        <span>压缩比: 80:1</span>
                        <span>Web优化</span>
                    </div>
                </div>
            </div>

            <div class="comparison-table">
                <h3>编码标准对比</h3>
                <table>
                    <thead>
                        <tr>
                            <th>标准</th>
                            <th>压缩效率</th>
                            <th>编码复杂度</th>
                            <th>解码复杂度</th>
                            <th>硬件支持</th>
                            <th>典型应用</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>H.264</td>
                            <td>基准</td>
                            <td>低</td>
                            <td>极低</td>
                            <td>所有设备</td>
                            <td>传统应用</td>
                        </tr>
                        <tr>
                            <td>H.265</td>
                            <td>2x</td>
                            <td>中高</td>
                            <td>中</td>
                            <td>广泛</td>
                            <td>4K流媒体</td>
                        </tr>
                        <tr>
                            <td>AV1</td>
                            <td>2.3x</td>
                            <td>高</td>
                            <td>中高</td>
                            <td>新增</td>
                            <td>Web应用</td>
                        </tr>
                        <tr>
                            <td>H.266</td>
                            <td>3x</td>
                            <td>极高</td>
                            <td>高</td>
                            <td>新兴</td>
                            <td>8K+内容</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </section>

    <section id="ai" class="section">
        <div class="container">
            <h2>AI与深度学习视频处理</h2>

            <div class="ai-section">
                <h3>前沿技术</h3>
                <div class="ai-grid">
                    <div class="ai-card">
                        <h4>神经视频编码 (NVC)</h4>
                        <p>使用深度学习替代传统变换编码，通过自编码器学习最优压缩表示</p>
                        <ul>
                            <li>基于GAN的感知优化编码</li>
                            <li>率失真优化的神经网络训练</li>
                            <li>超分辨率辅助编码</li>
                        </ul>
                    </div>
                    <div class="ai-card">
                        <h4>视频理解与检索</h4>
                        <p>基于Transformer和CLIP的视频语义理解，支持自然语言检索</p>
                        <ul>
                            <li>VideoMAE视频自监督学习</li>
                            <li>时空注意力机制</li>
                            <li>多模态视频-文本对齐</li>
                        </ul>
                    </div>
                    <div class="ai-card">
                        <h4>视频生成与编辑</h4>
                        <p>扩散模型创造逼真视频内容，支持文本到视频、视频编辑</p>
                        <ul>
                            <li>Stable Video Diffusion</li>
                            <li>Sora类长视频生成</li>
                            <li>可控视频生成</li>
                        </ul>
                    </div>
                    <div class="ai-card">
                        <h4>实时视频超分</h4>
                        <p>轻量级CNN网络实现低延迟的高质量视频超分辨率</p>
                        <ul>
                            <li>Real-ESRGAN Video</li>
                            <li>基于流网络的高效推理</li>
                            <li>量化加速与部署优化</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="ai-frameworks">
                <h3>推荐框架与工具</h3>
                <div class="framework-list">
                    <div class="framework">
                        <strong>PyTorch Video</strong>
                        <p>PyTorch生态的视频处理库，提供高效的视频数据加载和预训练模型</p>
                    </div>
                    <div class="framework">
                        <strong>TensorFlow I/O</strong>
                        <p>TensorFlow的视频IO扩展，支持多种格式和硬件加速</p>
                    </div>
                    <div class="framework">
                        <strong>Decord</strong>
                        <p>高效的视频解码库，针对深度学习场景优化</p>
                    </div>
                    <div class="framework">
                        <strong>OpenCV</strong>
                        <p>经典计算机视觉库，视频处理基础功能</p>
                    </div>
                    <div class="framework">
                        <strong>FFmpeg</strong>
                        <p>完整的视频处理工具链，编解码、转码、滤镜处理</p>
                    </div>
                    <div class="framework">
                        <strong>DaVinci Resolve</strong>
                        <p>专业视频后期处理，AI辅助调色与修复</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section id="tools" class="section alt-bg">
        <div class="container">
            <h2>工具与框架</h2>

            <div class="tool-categories">
                <div class="category">
                    <h3>开发库</h3>
                    <ul>
                        <li><strong>FFmpeg</strong> - 命令行工具 + 库，视频处理的瑞士军刀</li>
                        <li><strong>OpenCV</strong> - cv2.VideoCapture, cv2.VideoWriter</li>
                        <li><strong>PyAV</strong> - Python绑定FFmpeg</li>
                        <li><strong>MoviePy</strong> - 视频编辑Python库</li>
                    </ul>
                </div>

                <div class="category">
                    <h3>AI框架</h3>
                    <ul>
                        <li><strong>PyTorch Video</strong> - 视频深度学习</li>
                        <li><strong>TensorFlow Hub</strong> - 预训练视频模型</li>
                        <li><strong>Hugging Face</strong> - 视频生成模型（Video LDM, Zeroscope）</li>
                        <li><strong>ComfyUI</strong> - 视频生成工作流工具</li>
                    </ul>
                </div>

                <div class="category">
                    <h3>分析工具</h3>
                    <ul>
                        <li><strong>VMAF</strong> - Netflix视频质量指标</li>
                        <li><strong>BD-Rate计算工具</strong> - 编码效率评估</li>
                        <li><strong>QoE评估工具</strong> - 用户体验质量</li>
                        <li><strong>视频分析Dashboard</strong> - 实时监控工具</li>
                    </ul>
                </div>

                <div class="category">
                    <h3>云服务</h3>
                    <ul>
                        <li><strong>AWS Elemental</strong> - 专业视频转码服务</li>
                        <li><strong>Google Video AI</strong> - 视频内容分析</li>
                        <li><strong>Azure Video Indexer</strong> - 智能视频分析</li>
                        <li><strong>Cloudflare Stream</strong> - 低延迟流媒体分发</li>
                    </ul>
                </div>
            </div>
        </div>
    </section>

    <section id="code" class="section">
        <div class="container">
            <h2>代码示例</h2>

            <div class="code-section">
                <h3>Python 视频处理代码</h3>

                <div class="code-block">
                    <h4>1. 使用OpenCV读取和播放视频</h4>
                    <pre><code>import cv2

# 打开视频文件
cap = cv2.VideoCapture('input.mp4')

# 检查视频是否成功打开
if not cap.isOpened():
    print("无法打开视频文件")
    exit()

# 获取视频属性
fps = cap.get(cv2.CAP_PROP_FPS)
width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

print(f"视频信息: {width}x{height}, {fps} FPS, 共{frame_count}帧")

# 逐帧读取视频
while cap.isOpened():
    ret, frame = cap.read()
    if not ret:
        break

    # 显示当前帧
    cv2.imshow('Video', frame)

    # 按'q'退出
    if cv2.waitKey(25) & 0xFF == ord('q'):
        break

# 释放资源
cap.release()
cv2.destroyAllWindows()</code></pre>
                </div>

                <div class="code-block">
                    <h4>2. 使用OpenCV保存视频</h4>
                    <pre><code>import cv2
import numpy as np

# 创建VideoWriter对象
width, height = 640, 480
fps = 30
fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # 或 'H264', 'XVID'
out = cv2.VideoWriter('output.mp4', fourcc, fps, (width, height))

# 写入视频帧（示例：生成渐变色视频）
for i in range(300):
    frame = np.zeros((height, width, 3), dtype=np.uint8)
    frame[:, :, 0] = int(i / 300 * 255)  # B通道
    frame[:, :, 1] = int((300 - i) / 300 * 255)  # G通道
    frame[:, :, 2] = 128  # R通道
    out.write(frame)

# 释放资源
out.release()
print("视频已保存为 output.mp4")</code></pre>
                </div>

                <div class="code-block">
                    <h4>3. 使用MoviePy视频编辑</h4>
                    <pre><code>from moviepy.editor import VideoFileClip, TextClip, CompositeVideoClip

# 读取视频
video = VideoFileClip('input.mp4')

# 裁剪视频（从10秒到30秒）
clipped = video.subclip(10, 30)

# 添加文字
txt_clip = TextClip("Video Demo", fontsize=70, color='white')
txt_clip = txt_clip.set_pos('center').set_duration(5)

# 合成视频
final = CompositeVideoClip([clipped, txt_clip])

# 调整速度（2倍速）
fast_video = final.fx(lambda v: v.speedx(2))

# 添加背景音乐
# final = final.set_audio(AudioFileClip('background.mp3'))

# 导出视频
final.write_videofile('output.mp4', fps=video.fps)</code></pre>
                </div>

                <div class="code-block">
                    <h4>4. 使用PyAV进行高效视频解码</h4>
                    <pre><code>import av

# 打开视频容器
container = av.open('input.mp4')

# 获取视频流
stream = container.streams.video[0]

# 逐帧解码
for packet in container.demux(stream):
    for frame in packet.decode():
        # 转换为numpy数组
        img = frame.to_ndarray(format='rgb24')

        # 处理帧...
        print(f"Frame: {frame.index}, size: {frame.width}x{frame.height}")

container.close()</code></pre>
                </div>

                <div class="code-block">
                    <h4>5. 调用FFmpeg命令进行视频转码</h4>
                    <pre><code>import subprocess

# 视频转码示例
cmd = [
    'ffmpeg',
    '-i', 'input.mp4',           # 输入文件
    '-c:v', 'libx264',           # 视频编码器
    '-preset', 'medium',         # 编码预设
    '-crf', '23',                # 质量控制
    '-c:a', 'aac',               # 音频编码器
    '-b:a', '128k',              # 音频比特率
    'output.mp4'                 # 输出文件
]

subprocess.run(cmd, check=True)
print("转码完成")</code></pre>
                </div>
            </div>

            <div class="code-section">
                <h3>Golang 视频处理代码</h3>

                <div class="code-block">
                    <h4>1. 使用FFmpeg库解码视频</h4>
                    <pre><code>package main

import (
    "fmt"
    "github.com/mjibson/go-dsp/ffmpeg"
)

func main() {
    // 打开视频文件
    file, err := ffmpeg.Open("input.mp4")
    if err != nil {
        panic(err)
    }
    defer file.Close()

    // 获取视频流信息
    videoStream := file.Streams()[0]
    fmt.Printf("视频: %dx%d, %s\n",
        videoStream.Width(),
        videoStream.Height(),
        videoStream.Codec())

    // 读取视频帧
    for {
        packet, err := file.ReadPacket()
        if err != nil {
            break
        }

        if packet.StreamIndex() == 0 {
            // 处理视频包
            fmt.Printf("读取到视频包，大小: %d bytes\n", packet.Data().Len())
        }
    }
}</code></pre>
                </div>

                <div class="code-block">
                    <h4>2. 使用Muxy封装视频流</h4>
                    <pre><code>package main

import (
    "github.com/giorgisio/goav/avcodec"
    "github.com/giorgisio/goav/avformat"
)

func main() {
    // 初始化FFmpeg库
    avformat.AvRegisterAll()
    avcodec.AvCodecRegisterAll()

    // 创建输出格式上下文
    outFormatCtx := avformat.AvformatAllocOutputContext2(
        nil,
        nil,
        "mp4",
        "output.mp4",
    )

    // 添加视频流
    videoStream := outFormatCtx.AvStreamNew()

    // 配置视频编码参数
    videoCodec := avcodec.AvcodecFindEncoderByName(avcodec.AV_CODEC_ID_H264)
    videoCodecCtx := videoCodec.AvcodecAllocContext3()

    videoCodecCtx.SetCodecType(avformat.AVMEDIA_TYPE_VIDEO)
    videoCodecCtx.SetCodecId(avcodec.AV_CODEC_ID_H264)
    videoCodecCtx.SetWidth(640)
    videoCodecCtx.SetHeight(480)
    videoCodecCtx.SetTimeBase(avformat.NewRational(1, 30))  // 30 FPS

    // 打开编码器
    videoCodecCtx.AvcodecOpen2(videoCodec, nil)

    // 写入视频头
    outFormatCtx.AvformatWriteHeader(nil)

    // 编码和写入帧（示例）
    // ... 编码逻辑 ...

    // 写入视频尾
    outFormatCtx.AvWriteTrailer()
}</code></pre>
                </div>

                <div class="code-block">
                    <h4>3. 使用exec包调用FFmpeg命令</h4>
                    <pre><code>package main

import (
    "fmt"
    "os/exec"
)

func main() {
    // 调用FFmpeg进行视频转码
    cmd := exec.Command(
        "ffmpeg",
        "-i", "input.mp4",           // 输入文件
        "-c:v", "libx264",           // 视频编码器
        "-preset", "medium",         // 编码预设
        "-crf", "23",                // 质量控制
        "-c:a", "aac",               // 音频编码器
        "-b:a", "128k",              // 音频比特率
        "output.mp4",                // 输出文件
    )

    // 执行命令
    output, err := cmd.CombinedOutput()
    if err != nil {
        fmt.Printf("错误: %v\n", err)
        fmt.Printf("输出: %s\n", string(output))
        return
    }

    fmt.Println("转码完成")}</code></pre>
                </div>

                <div class="code-block">
                    <h4>4. 获取视频元信息</h4>
                    <pre><code>package main

import (
    "fmt"
    "os/exec"
    "encoding/json"
)

type VideoInfo struct {
    Streams []struct {
        CodecName string `json:"codec_name"`
        Width     int    `json:"width"`
        Height    int    `json:"height"`
        Fps       string `json:"r_frame_rate"`
        Duration  string `json:"duration"`
    } `json:"streams"`
}

func main() {
    // 使用ffprobe获取视频信息
    cmd := exec.Command(
        "ffprobe",
        "-v", "error",
        "-select_streams", "v:0",
        "-show_entries", "stream=codec_name,width,height,r_frame_rate,duration",
        "-of", "json",
        "input.mp4",
    )

    output, err := cmd.Output()
    if err != nil {
        panic(err)
    }

    // 解析JSON
    var info VideoInfo
    if err := json.Unmarshal(output, &info); err != nil {
        panic(err)
    }

    // 打印视频信息
    if len(info.Streams) > 0 {
        stream := info.Streams[0]
        fmt.Printf("编码器: %s\n", stream.CodecName)
        fmt.Printf("分辨率: %dx%d\n", stream.Width, stream.Height)
        fmt.Printf("帧率: %s\n", stream.Fps)
        fmt.Printf("时长: %s秒\n", stream.Duration)
    }
}</code></pre>
                </div>

                <div class="code-block">
                    <h4>5. 批量视频处理</h4>
                    <pre><code>package main

import (
    "fmt"
    "os/exec"
    "path/filepath"
    "os"
)

func main() {
    // 批量处理视频文件
    inputDir := "./input"
    outputDir := "./output"

    // 创建输出目录
    os.MkdirAll(outputDir, 0755)

    // 遍历输入目录
    err := filepath.Walk(inputDir, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }

        // 跳过目录
        if info.IsDir() {
            return nil
        }

        // 只处理视频文件
        ext := filepath.Ext(path)
        if ext != ".mp4" && ext != ".mkv" && ext != ".avi" {
            return nil
        }

        // 构造输出路径
        outputFile := filepath.Join(outputDir, filepath.Base(path))

        // 转码命令
        cmd := exec.Command(
            "ffmpeg",
            "-i", path,
            "-c:v", "libx264",
            "-crf", "23",
            "-preset", "fast",
            outputFile,
        )

        // 执行转码
        fmt.Printf("处理: %s -> %s\n", path, outputFile)
        if err := cmd.Run(); err != nil {
            fmt.Printf("错误: %v\n", err)
            return err
        }

        return nil
    })

    if err != nil {
        panic(err)
    }

    fmt.Println("批量处理完成")
}</code></pre>
                </div>
            </div>

            <div class="code-tips">
                <h3>实用技巧</h3>
                <div class="tips-grid">
                    <div class="tip">
                        <strong>Python开发推荐</strong>
                        <p>使用OpenCV进行快速原型开发，PyAV用于高性能场景，MoviePy用于视频编辑</p>
                    </div>
                    <div class="tip">
                        <strong>Golang开发推荐</strong>
                        <p>使用exec包调用FFmpeg命令处理视频，使用go-av等库进行底层编解码</p>
                    </div>
                    <div class="tip">
                        <strong>性能优化</strong>
                        <p>使用硬件加速（NVIDIA NVENC、Intel QSV）提升编码速度</p>
                    </div>
                    <div class="tip">
                        <strong>并行处理</strong>
                        <p>利用Golang的goroutine或Python的多进程进行批量视频处理</p>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>VideoLearn</h3>
                    <p>视频处理技术学习资源</p>
                </div>
                <div class="footer-section">
                    <h3>快速链接</h3>
                    <ul>
                        <li><a href="#basics">基础知识</a></li>
                        <li><a href="#codec">编解码技术</a></li>
                        <li><a href="#ai">AI视频处理</a></li>
                        <li><a href="#tools">工具框架</a></li>
                        <li><a href="#code">代码示例</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h3>推荐工具</h3>
                    <ul>
                        <li><a href="https://ffmpeg.org" target="_blank">FFmpeg</a></li>
                        <li><a href="https://opencv.org" target="_blank">OpenCV</a></li>
                        <li><a href="https://pytorch.org" target="_blank">PyTorch</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; VideoLearn. 纯静态网站</p>
            </div>
        </div>
    </footer>

    <script>
        // 平滑滚动
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // 导航栏滚动效果
        window.addEventListener('scroll', function() {
            const navbar = document.querySelector('.navbar');
            if (window.scrollY > 50) {
                navbar.classList.add('scrolled');
            } else {
                navbar.classList.remove('scrolled');
            }
        });

        // 代码高亮（如果有代码块）
        document.addEventListener('DOMContentLoaded', function() {
            console.log('VideoLearn - 视频处理学习网站加载完成');
        });
    </script>
</body>
</html>